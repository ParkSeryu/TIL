- 1차캐시
  - find할때 db가 아니라 1차캐시를 먼저 뒤져서 캐시값 조회가 성공할시, 바로 가져온다.
  - 1차캐시에 해당 Entity가 없으면, DB에서 조회 후 1차 캐시에 저장한다.
    ⇒ 따라서, 영속 엔티티의 동일성을 보장한다. (db전에 1차캐시에서 먼저 조회)

→ 비즈니스가 정말 복잡할때 성능상에 이점이 있음. (컨셉적으로 알아두는 것)

- 더티체킹(변경감지)

  - 영속성 컨텍스트 안에 엔티티와 스냅샷을 비교하여 (일일히 비교함) 엔티티가 바뀌면 쓰기 지연 SQL 저장소에서 업데이트를 반영함

- flush

  - 영속성 컨텍스트의 변경내용을 데이터베이스에 반영 (쓰기 지연 SQL 저장소의 쿼리를 DB에 전송)
  - em.flush() → 기본값은 쿼리 실행 시 flush

- 준영속 상태

  - 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached)
  - 영속성 컨텍스트가 제공하는 기능을 사용 못함
  - 영속성 컨텍스트에서 관리하지 말라고 하는것임

- 연관 관계

  - 단방향 연관관계
  - 객체를 테이블에 맞추어 모델링 (참조 대신에 외래키를 그대로 사용) - 객체를 테이블에 맞추어 데이터 중심으로 모델링하면, 협력 관계를 만들 수 없다. 1. 테이블은 외래 키로 조인하여 연관 테이블을 찾는다. 2. 객체는 참조를 사용해서 연관 객체를 찾는다. 3. 테이블과 객체 사이에는 이러한 간격이 있다.
    -> 그렇기 때문에 @ManyToOne이랑 @JoinColumn 이런걸로 객체와 매핑해준다.

  - 양방향 연관관계
    - 양방향 연관관계와 연관관계의 주인
      - 외래키가 있는 쪽이 연관관계의 주인
      - 테이블에서는 한쪽이 외래키를 갖고있는 것 만으로도 두 테이블에서 양쪽으로 참조가 가능하다.
      - 문제는 객체, 객체에서는 한쪽이 다른 한쪽을 알고있는 것만으로는 양쪽으로 참조를 할 수 없다.
    - 연관관계의 주인
      - 객체 연관관계 -> 단방향 x 2 개 => 2개
      - 테이블 연관관계 -> 양방향 => 1개 ( 외래 키 하나로 두 테이블의 연관관계를 관리함 )
        => 즉, 양방향으로 참조하려면 단방향 연관관계를 2개 만들어야 한다. (순환참조가 되므로 안티패턴이긴 함.)
    - 양방향 매핑 규칙
      - 객체의 두 관계중 하나를 연관관계의 주인으로 지정
      - 주인이 아닌쪽은 읽기만 하고, 주인은 등록 및 수정 가능
      - 연관관계의 주인만이 외래 키를 관리(등록 ,수정)
      - 주인이 아니면! mappedBy 속성으로 주인 지정
        => fk를 갖는 엔티티에 mappedBy를 사용하면 된다.

  -> 단방향 매핑만으로도 이미 연관관계 매핑은 완료
  -> JPQL에서 역방향으로 탐색할 일이 많음
  -> 외래키의 위치를 기준으로 연관관계의 주인으로 정해야함. (다인쪽)

- 일대다 단방향 정리

  - 일대다 단방향은 일대다(1:N)에서 일(1)이 연관관계의 주인
  - DB 테이블 일대다 관계는 항상 다(N) 쪽에 외래 키가 있음
  - 객체와 테이블의 차이 때문에 반대편 테이블에 외래 키를 관리하는 특이한 구조
  - @JoinColumn을 꼭 사용해야 함.
  - 엔티티가 관리하는 외래 키가 다른 테이블에 있어, 추가로 UPDATE SQL이 실행되므로 지양하자.

- 일대일 관계
  - 주 테이블이나 대상 테이블 중에 외래 키 선택 가능
  - 외래 키에 데이터베이스 유니크(UNI) 제약조건 추가

- 주 테이블에 외래 키
  - 주 객체가 대상 객체의 참조를 가지는 것 처럼 주 테이블에 외래 키를 두고 대상 테이블을 찾음
  - 객체지향 개발자 선호
  - JPA 매핑 편리
  - 장점: 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능
  - 단점: 값이 없으면 외래 키에 null 허용
- 대상 테이블에 외래 키

  - 대상 테이블에 외래 키가 존재
  - 전통적인 데이터베이스 개발자 선호
  - 장점: 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지
  - 단점: 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨(프록시는 뒤에서 설명)

- 다대다 관계
  - 관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없음
  - 연결 테이블을 추가해서 일대다, 다대일 관계로 풀어내야함
    - 하지만, 객체는 컬렉션을 사용해서 객체 2개로 다대다 관계 가능
- @ManyToMany 사용, @JoinTable로 연결 테이블 지정
  - 편리해 보이지만 실무에서 사용 X
  - 연결 테이블이 단순히 연결만 하고 끝나지 않음
  - 추가 데이터가 들어올 수 있으나, 쓸수가 없음 (매핑정보만 들어옴)
    -> 제약조건이 심해, 실무에선 활용하기가 어렵다. 연결 테이블을 엔티티로 승격해서 사용해야 한다.

- 상속관계 매핑
  - 공통 분모의 부모 테이블이 있을때 JOIN TABLE, SINGLE TABLE 전략등을 사용 할 수 있다

- 프록시 객체
  - em.find() : 데이터베이스를 통해서 실제 엔티티 객체 조회
  - em.getReference(): 데이터베이스 조회를 미루는 가자(프록시) 엔티티 객체 조회
  - 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환

- 영속성 전이 (CASCADE)
  - 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함게 영속 상태로 만들고 싶을 때
  - ex) 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장.
  - 영속성 전이는 연관관계를 매핑하는 것과 아무 관련이 없음
  - 엔티티를 영속화 할 때 연관된 엔티티도 함께 영속화하는 편리함을 제공할 뿐
  - ALL: 모두 적용, PERSIST: 영속 (이정도 사용)
    - 하나의 부모가 자식들을 관리할 때 주로 사용됨. (첨부파일 이나 첨부파일 경로 이런애들)
    - 단일소유자 일 경우에 많이 사용된다.
- 고아객체
  - 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동 삭제
  - 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능
  - 참조하는 곳이 하나일 때 사용해야함!
  - 특정 엔티티가 개인 소유할 때 사용
  - 개념적으로 부모를 제거하면 자식은 고아가 되므로, 자식들도 삭제된다.
- CASCADE + orphanRemoval 
  - 스스로 생명주기를 관리하는 엔티티는 em.persist()로 영속화, em.remove()로 제거
  - 두 옵션을 모두 활성화 하면 부모 엔티티를 통해서 자식의 생명 주기를 관리할 수 있음
  - DDD의 Aggregate Root 개념을 구현할 때 유용