- 1차캐시
    - find할때 db가 아니라 1차캐시를 먼저 뒤져서 캐시값 조회가 성공할시, 바로 가져온다.
    - 1차캐시에 해당 Entity가 없으면, DB에서 조회 후 1차 캐시에 저장한다.

⇒ 따라서, 영속 엔티티의 동일성을 보장한다. (db전에 1차캐시에서 먼저 조회)

→ 비즈니스가 정말 복잡할때 성능상에 이점이 있음. (컨셉적으로 알아두는 것)

- 더티체킹(변경감지)
    - 영속성 컨텍스트 안에 엔티티와 스냅샷을 비교하여 (일일히 비교함) 엔티티가 바뀌면 쓰기 지연 SQL 저장소에서 업데이트를 반영함

- flush
    - 영속성 컨텍스트의 변경내용을 데이터베이스에 반영 (쓰기 지연 SQL 저장소의 쿼리를 DB에 전송)
    - em.flush() → 기본값은 쿼리 실행 시 flush

- 준영속 상태
    - 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached)
    - 영속성 컨텍스트가 제공하는 기능을 사용 못함
    - 영속성 컨텍스트에서 관리하지 말라고 하는것임

- 연관 관계
    - 단방향 연관관계
    - 객체를 테이블에 맞추어 모델링 (참조 대신에 외래키를 그대로 사용)
        - 객체를 테이블에 맞추어 데이터 중심으로 모델링하면, 협력 관계를 만들 수 없다.
            1. 테이블은 외래 키로 조인하여 연관 테이블을 찾는다.
            2. 객체는 참조를 사용해서 연관 객체를 찾는다.
            3. 테이블과 객체 사이에는 이러한 간격이 있다.
    -> 그렇기 때문에 @ManyToOne이랑 @JoinColumn 이런걸로 객체와 매핑해준다.

    - 양방향 연관관계
        - 양방향 연관관계와 연관관계의 주인
            - 테이블에서는 한쪽이 외래키를 갖고있는 것 만으로도 두 테이블에서 양쪽으로 참조가 가능하다.
            - 문제는 객체, 객체에서는 한쪽이 다른 한쪽을 알고있는 것만으로는 양쪽으로 참조를 할 수 없다.
        - 연관관계의 주인
            - 객체 연관관계 -> 단방향 x 2 개 => 2개
            - 테이블 연관관계 -> 양방향 => 1개 ( 외래 키 하나로 두 테이블의 연관관계를 관리함 )
            => 즉, 양방향으로 참조하려면 단방향 연관관계를 2개 만들어야 한다. (순환참조가 되므로 안티패턴이긴 함.)
        - 양방향 매핑 규칙
            - 객체의 두 관계중 하나를 연관관계의 주인으로 지정
            - 주인이 아닌쪽은 읽기만 하고, 주인은 등록 및 수정 가능
            - 연관관계의 주인만이 외래 키를 관리(등록 ,수정)
            - 주인이 아니면! mappedBy 속성으로 주인 지정
            => fk를 갖는 엔티티에 mappedBy를 사용하면 된다.
    
    => 단방향 매핑만으로도 이미 연관관계 매핑은 완료
    -> JPQL에서 역방향으로 탐색할 일이 많음
    : 외래키의 위치를 기준으로 연관관계의 주인으로 정해야함. (다인쪽)

